# kafka-basic

# 카프카 디자인의 특징
* 분산 시스템
  * 카프카는 분산 시스템이기 때문에 유동적으로 서버를 늘릴 수 있다.
* 페이지 캐시
  * 처리량을 높이기 위해 페이지 캐시를 이용도록 디자인
  * 잔여 메모리 일부를 페이지 캐시로 유지해 OS의 전체적인 성능 향상
  * 메모리를 이용해 디스크에 읽고 쓰기를 하지 않고 페이지 캐시를 통해서 읽고 쓰는 방식
  * 처리 속도가 매우 빠르며 전체적인 성능 향상
* 배치 전송 처리
  * 서버와 클라이언트 사이 또는 서버 내부적으로 데이터를 주고받는 과정에서 I/O가 발생
  * 작은 I/O가 빈번하게 일어나게 되면 이 또한 속도를 저하시키는 원인
  * 따라서 카프카에서는 작은 I/O를 묶어서 처리할 수 있도록 배치 작업으로 처리


# 카프카 데이터 모델
* 토픽
  * 카프카 클러스터는 토픽이라 불리는 곳에 데이터를 저장 (우리가 많이 사용하는 메일 시스템에 비유하면, 토픽은 메일주소라고 생각하면 이해가 쉽다)
  * 토픽 이름은 249자 미만으로 영문, 숫자, '.', '_', '-'를 조합하여 자유롭게 생성
* 파티션
  * 토픽을 분할 한 것
  * 효율적인 메시지 전송과 속도를 높이려면 토픽의 파티션 수를 늘려줘야 함
  * 병렬 처리 방식으로 토픽에 메시지를 보낼 수 있다
  * 그럼 무조건 파티션 수를 늘려야 하나?
    * 파티션 수가 늘어나면 오히려 카프카에 좋지 않은 영향을 미칠 수도 있다.
    * 파일 핸들러의 낭비
      * 각 파티션은 브로커의 디렉토리와 매핑되고, 저장되는 데이터마다 2개의 파일(인덱스와 실제 데이터)이 존재
      * 카프카에서는 모든 디렉토리의 파일들에 대해 파일 핸들을 열게 된다
      * 결국 파티션의 수가 많을수록 파일 핸들 수 역시 많아지게 되어 리소스 낭비
    * 장애 복구 시간 증가
      * 브로커에 토픽이 존재하고, 토픽은 여러개의 파티션으로 나뉘어 있으므로, 브로커에는 여러 개의 파티션이 존재
      * 각 파티션마다 리플리케이션이 동작하게 되며, 하나는 파티션의 리더이고 나머지는 파티션의 팔로워가 된다.
      * 만약 브로커가 다운되면 해당 브로커에 리더가 있는 파티션은 일시적으로 사용할 수 없게 되므로, 카프카는 리더를 팔로워 중 하나로 이동시켜 클라이언트 요청을 처리 할 수 있게 한다.
      * 이와 같은 장애처리는 컨트롤러 역할을 수행하는 브로커가 수행
      * 브로커가 갑자기 종료되면, 일시적으로 이 브로커에 있는 파티션은 사용할 수 없으며, 파티션의 리더를 다른 브로커가 있는 곳으로 이동시켜야 사용할 수 있기 때문에 파티션이 증가함에 따라 장애 시간이 증가 할 수 있다.
    * 내 토픽의 적절한 파티션 수는?
      * 먼저 토픽의 파티션 수를 정할 때 원하는 목표 처리량의 기준을 잡아야 한다.
      * 프로듀서를 통해서 초당 10개의 메시지를 카프카의 토픽으로 보낸다 가정
      * 카프카의 토픽에서 초당 10개의 메시지를 받아줘야 한다.
      * 만약 해당 토픽에서 파티션을 1로 했을 때 초당 5개의 메시지만 받아준다면 파티션을 2로 늘려서 목표 처리량을 처리 할수 있도록 변경
  * 오프셋과 메시지 순서
    * 카프카에서는 각 파티션마다 메시지가 저장되는 위치를 오프셋(offset)이라고 부른다.
    * 오프셋은 파티션 내에서 유일
    * 프로듀서가 전송한 메시지들이 저장된 위치를 유니크하고 순차적인 숫자 형태인 0, 1, 2 같은 형태로 저장
# 카프카의 고가용성과 리플리케이션
  * 카프카는 분산 애플리케이션으로 서버의 물리적 장애가 발생하는 경우에도 높은 가용성을 보장
  * 이를 위해 카프카는 리플리케이션 기능을 제공
  * 카프카의 리플리케이션은 토픽 자체를 리플리케이션하는 것이 아니라, 토픽을 이루는 각각의 파티션을 리플리케이션 하는 것

  * 리플리케이션 팩터와 리더, 팔로워의 역할
    * 카프카에서는 리플리케이션 팩터(Replication Factor) 값을 통해 리플리케이션 수를 지정한다. 기본값 설정 = 1
    * 각 토픽별로 다른 리플리케이션 팩터 값을 설정 할 수 있다.
    * 운영 중에도 토픽의 리플리케이션 팩터 값은 변경 가능
    * 클러스터 내 모든 브로커에 동일하게 설정해야 하며, Config 내용을 변경한 후 브로커 1대씩 재시작을 하면 변경 내용이 적용
    * 카프카에서는 리플리케이션으로 구성된 파티션을 구분하기 위해 주키퍼와 동일하게 리더(원본)와 팔로워(복제본)라고 부른다.
    * 리더와 팔로워는 각자 역할이 나뉘어 있는데 가장 중요한 핵심은 모든 읽기와 쓰기가 리더를 통해서만 일어난다.
    * 즉, 팔로워는 리더의 데이터를 그대로 리플리케이션만 하고 읽기와 쓰기에는 관여하지 않는다.


